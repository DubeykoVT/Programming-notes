
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Дерево отрезков — Конспект</title>
<link rel="stylesheet" href="styles/main.css">
<link rel="stylesheet" href="styles/theory.css">
<link rel="stylesheet" href="styles/code.css">
</head>
<body>

<a href="index.html" class="back">← Назад</a>

<h1>Дерево отрезков</h1>

<div class="interactive-block">
  <button class="toggle">Показать / скрыть схему структуры дерева</button>
  <div class="content">
    <img src="images/segment_tree_structure.png" style="max-width:100%;">
  </div>
</div>

<div class="interactive-block">
  <button class="toggle">Показать / скрыть Lazy Propagation</button>
  <div class="content">
    <img src="images/lazy_propagation.png" style="max-width:100%;">
  </div>
</div>

<h2>Полный конспект</h2>
<p>Здесь будет длинный (5+ страниц) текст, который ты попросишь далее дополнить...</p>

<h2>Исходный код</h2>
<pre><code class="cpp">
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define int long long
#define debug(x) cerr &lt;&lt; __LINE__ &lt;&lt; ": " &lt;&lt; (#x) &lt;&lt; " = " &lt;&lt; (x) &lt;&lt; endl;

const int inf = 1e10;

struct Node{
    int x;
    int push;
    int sz;
    Node(int a = 0, int b = 0, int c = 0){
        x = a;
        push = b;
        sz = c;
    }
    Node operator + (Node a){
        return Node(x + a.x, 0, sz + a.sz);
    }
};

Node NullN(0, 0, 0);

struct Tree{
    vector<Node> a;
    vector<Node> t;
    Tree(vector<Node> x) {
        a = x;
        t.assign(4 * x.size(), Node(0, 0, 0));
    }

    void build(int v, int l, int r){
        if(l + 1 == r){
            t[v] = a[l];
            t[v].sz = 1;
            return;
        }
        if(l >= r){
            return;
        }
        int mid = (l + r) / 2;
        build(2 * v + 1, l, mid);
        build(2 * v + 2, mid, r);
        t[v] = t[2 * v + 1] + t[2 * v + 2];
    }
    Node get(int v, int l, int r, int l1, int r1){
        if(l >= l1 and r <= r1){
            return t[v];
        }
        if(l >= r1 or r <= l1){
            return NullN;
        }
        push(v);
        int mid = (l + r) / 2;
        return get(2 * v + 1, l, mid, l1, r1) + get(2 * v + 2, mid, r, l1, r1);
    }
    void update(int v, int l, int r, int pos, int val){
        if(l + 1 == r){
            t[v] = val;
            return;
        }
        push(v);
        int mid = (l + r) / 2;
        if(mid > pos){
            update(2 * v + 1, l, mid, pos, val);
        }
        else{
            update(2 * v + 2, mid, r, pos, val);
        }
        t[v] = t[2 * v + 1] + t[2 * v + 2];
    }
    void update1(int v, int l, int r, int l1, int r1, int val){
        if(l >= l1 and r <= r1){
            t[v].x += val * t[v].sz;
            t[v].push += val;
            return;
        }
        if(l >= r1 or r <= l1){
            return;
        }
        push(v);
        int mid = (l + r) / 2;
        update1(2 * v + 1, l, mid, l1, r1, val);
        update1(2 * v + 2, mid, r, l1, r1, val);
        t[v] = t[2 * v + 1] + t[2 * v + 2];
    }
    void push(int v){
        t[2 * v + 1].push += t[v].push;
        t[2 * v + 1].x += t[v].push * (t[2 * v + 1].sz);
        t[2 * v + 2].push += t[v].push;
        t[2 * v + 2].x += t[v].push * (t[2 * v + 2].sz);
        t[v].push = 0;
    }
};
</code></pre>

<script src="scripts/interactive.js"></script>
</body>
</html>
