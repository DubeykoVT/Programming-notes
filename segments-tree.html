<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Дерево отрезков — Конспект</title>

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles/main.css">
  <link rel="stylesheet" href="styles/theory.css">
  <link rel="stylesheet" href="styles/code.css">
  <script defer src="scripts/interactive.js"></script>
</head>
<body class="light">
  <header class="topbar">
    <div class="container">
      <a class="brand" href="index.html">Конспект по программированию 2025-2026</a>
      <div class="controls">
        <a class="btn small" href="index.html">Назад к оглавлению</a>
        <button id="themeToggle" class="btn outline">Тёмная тема</button>
      </div>
    </div>
  </header>

  <main class="container content">
    <article class="theory">
      <h1>Дерево отрезков</h1>

      <section id="definition">
        <h2>Определение и назначение</h2>
        <p>Дерево отрезков — это структура данных для эффективных запросов и обновлений на подотрезках массива.</p>
      </section>

      <section id="structure">
        <h2>Структура дерева</h2>
        <div class="diagram">
<pre class="mermaid">
graph TD
  A([0..8)) --> B([0..4))
  A --> C([4..8))
  B --> D([0..2))
  B --> E([2..4))
  C --> F([4..6))
  C --> G([6..8))
  D --> H([0])
  D --> I([1])
  E --> J([2])
  E --> K([3])
  F --> L([4])
  F --> M([5])
  G --> N([6])
  G --> O([7])
</pre>
        </div>
      </section>

      <section id="build">
        <h2>Построение дерева</h2>
        <p>Рекурсивное построение за O(n).</p>
      </section>

      <section id="queries">
        <h2>Операции запроса</h2>
        <p>Рекурсивный поиск по отрезку; работает за O(log n).</p>
      </section>

      <section id="updates">
        <h2>Операции обновления</h2>
        <p>Точечные обновления и диапазонные с lazy propagation.</p>
      </section>

      <section id="examples">
        <h2>Примеры использования</h2>
        <p>Примеры ручных прогонов — build → update → get.</p>
        <div class="example">
          <button class="btn" onclick="showExample()">Показать пример</button>
          <pre id="exampleOut" class="output"></pre>
        </div>
      </section>

      <section id="code">
        <h2>Интегрированный код (без изменений)</h2>
        <pre><code class="language-cpp">#include <bits/stdc++.h>
using namespace std;

#define int long long
#define debug(x) cerr << __LINE__ << ": " << (#x) << " = " << (x) << endl;

const int inf = 1e10;

struct Node{
    int x;
    int push;
    int sz;
    Node(int a = 0, int b = 0, int c = 0){
        x = a;
        push = b;
        sz = c;
    }
    Node operator + (Node a){
        return Node(x + a.x, 0, sz + a.sz);
    }
};

Node NullN(0, 0, 0);

struct Tree{
    vector<Node> a;
    vector<Node> t;
    Tree(vector<Node> x) {
        a = x;
        t.assign(4 * x.size(), Node(0, 0, 0));
    }

    void build(int v, int l, int r){
        if(l + 1 == r){
            t[v] = a[l];
            t[v].sz = 1;
            return;
        }
        if(l >= r){
            return;
        }
        int mid = (l + r) / 2;
        build(2 * v + 1, l, mid);
        build(2 * v + 2, mid, r);
        t[v] = t[2 * v + 1] + t[2 * v + 2];
    }
    Node get(int v, int l, int r, int l1, int r1){
        if(l >= l1 and r <= r1){
            return t[v];
        }
        if(l >= r1 or r <= l1){
            return NullN;
        }
        push(v);
        int mid = (l + r) / 2;
        return get(2 * v + 1, l, mid, l1, r1) + get(2 * v + 2, mid, r, l1, r1);
    }
    void update(int v, int l, int r, int pos, int val){
        if(l + 1 == r){
            t[v] = val;
            return;
        }
        push(v);
        int mid = (l + r) / 2;
        if(mid > pos){
            update(2 * v + 1, l, mid, pos, val);
        }
        else{
            update(2 * v + 2, mid, r, pos, val);
        }
        t[v] = t[2 * v + 1] + t[2 * v + 2];
    }
    void update1(int v, int l, int r, int l1, int r1, int val){
        if(l >= l1 and r <= r1){
            t[v].x += val * t[v].sz;
            t[v].push += val;
            return;
        }
        if(l >= r1 or r <= l1){
            return;
        }
        push(v);
        int mid = (l + r) / 2;
        update1(2 * v + 1, l, mid, l1, r1, val);
        update1(2 * v + 2, mid, r, l1, r1, val);
        t[v] = t[2 * v + 1] + t[2 * v + 2];
    }
    void push(int v){
        t[2 * v + 1].push += t[v].push;
        t[2 * v + 1].x += t[v].push * (t[2 * v + 1].sz);
        t[2 * v + 2].push += t[v].push;
        t[2 * v + 2].x += t[v].push * (t[2 * v + 2].sz);
        t[v].push = 0;
    }
};</code></pre>

      </section>

    </article>
  </main>

  <footer class="container footer">
    <p>© Конспект по программированию 2025-2026</p>
  </footer>

  <!-- highlight.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>

  <!-- mermaid -->
  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true, theme: 'neutral' });
  </script>

  <!-- MathJax -->
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
</body>
</html>
