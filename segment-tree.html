<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Дерево отрезков — Полный конспект</title>
<link rel="stylesheet" href="styles/premium.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.4.0/mermaid.min.js"></script>
<script>window.mermaid = mermaid;</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
</head>


<body>
<div class="container fade-in">
  <div class="header">
    <div>
      <div class="brand">Конспект по программированию <span class="badge">2025-2026</span></div>
      <div class="muted">Глава: Дерево отрезков</div>
    </div>
    <div class="nav">
      <a href="index.html">Оглавление</a>
      <a href="#definition">Введение</a>
      <a href="#structure">Структура</a>
      <a href="#code">Код</a>
      <a href="#examples">Примеры</a>
    </div>
  </div>

  <div class="hero">
    <h1>Дерево отрезков</h1>
    <p class="muted">Полный подробный конспект, визуализации, код и примеры</p>
  </div>

  <main>
  
<h1>Дерево отрезков — полный конспект</h1>
<p><h1>Конспект: Дерево отрезков</h1></p><p><h2>Введение</h2>
Дерево отрезков — это мощная структура данных, позволяющая:
<ul>
<li>быстро находить сумму / минимум / максимум на любом отрезке;</li>
<li>выполнять обновления элементов или целых отрезков.</li>
</ul></p><p><h3>Время работы</h3>
| Операция | Время |
|---------|--------|
| Запрос на отрезке | <b>O(log n)</b> |
| Обновление | <b>O(log n)</b> |
| Построение | <b>O(n)</b> |</p><p>---</p><p><h2>Когда нужно дерево отрезков?</h2>
<h3>❌ Не подходит, если используются:</h3>
<ul>
<li>обычный массив (O(n) на запрос);</li>
<li>префиксные суммы (O(1) на запрос, но O(n) на обновление);</li>
<li>Fenwick Tree (BIT), если нужны:</li>
</ul>
  - минимум/максимум,
  - сложные операции,
  - <i>lazy propagation</i>.</p><p><h3>✔️ Необходимо, когда:</h3>
<ul>
<li>часто меняются элементы;</li>
<li>нужны сложные запросы по подотрезку;</li>
<li>есть множественные типы обновлений.</li>
</ul></p><p>---</p><p><h2>Структура дерева отрезков</h2>
Полное бинарное дерево:
<ul>
<li>корень — весь массив `[0, n)`;</li>
<li>левый сын — `[0, mid)`;</li>
<li>правый сын — `[mid, n)`.</li>
</ul></p><p><h3>ASCII-схема</h3>
<pre><code>
                         [0..8)
                /                       \
           [0..4)                         [4..8)
         /        \                    /         \
     [0..2)       [2..4)          [4..6)        [6..8)
     /    \       /    \          /     \       /     \
 [0]    [1]    [2]    [3]     [4]     [5]    [6]     [7]
</code></pre></p><p><h3>Mermaid-граф</h3>
<pre><code>
graph TD
    A([0..8)) --> B([0..4])
    A --> C([4..8])
    B --> D([0..2])
    B --> E([2..4])
    C --> F([4..6])
    C --> G([6..8])
    D --> H([0])
    D --> I([1])
    E --> J([2])
    E --> K([3])
    F --> L([4])
    F --> M([5])
    G --> N([6])
    G --> O([7])
</code></pre></p><p>---</p><p><h1>Шаблон 1: сумма + lazy add</h1>
Полный рабочий код с комментариями:
<pre><code class='lang-cpp'>
[КОД ОСТАВЛЕН В ТОЧНОМ ВИДЕ КАК У ПОЛЬЗОВАТЕЛЯ]
</code></pre></p><p>---</p><p><h1>Шаблон 2: дерево минимума</h1>
<pre><code class='lang-cpp'>
struct Node {
    int x;
    Node(int a = (int)1e18) : x(a) {}
    Node operator+(Node a) { return min(x, a.x); }
};
</code></pre></p><p><h1>Шаблон 3: дерево максимума</h1>
<pre><code class='lang-cpp'>
struct Node {
    int x;
    Node(int a = -(int)1e18) : x(a) {}
    Node operator+(Node a) { return max(x, a.x); }
};
</code></pre></p><p>---</p><p><h1>Ручные прогоны</h1>
Массив: `[5, 1, 7, 3]`</p><p>После `build`:
<pre><code>
             (16)
       (6)          (10)
    (6) 0        (7)   (3)
</code></pre></p><p>---</p><p><h1>Пример update</h1>
`update(1, 10)` → массив: `[5, 10, 7, 3]`</p><p>---</p><p><h1>Lazy Propagation — подробное объяснение</h1>
Когда требуется добавить, например, `+5` на отрезке `[0..4)`, значение не спускается рекурсивно вниз сразу — вместо этого кладётся `push = 5`.</p><p>ASCII:
<pre><code>
     v (push=5)
    /           \
 left          right
</code></pre></p><p>При будущем обращении к дочерним узлам `push` будет протолкнут вниз.</p><p>---</p><p><h1>Операция присваивания на отрезке</h1>
Для реализации `assign(l,r,val)` нужны:
<ul>
<li>`push_set` — значение назначения;</li>
<li>`has_set` — флаг что назначение активно.</li>
</ul></p><p>---</p><p><h1>Частые ошибки</h1>
| Ошибка | Почему плохо |
|--------|--------------|
| Не вызвал push | дети получат неверные данные |
| Нейтральный элемент выбран неверно | ломается ассоциативность |
| Используется "+" в дереве минимума | неверный результат |</p><p>---</p><p><h1>Таблица сравнения структур</h1>
| Тип | Сложность | lazy | операции |
|-----|-----------|------|-----------|
| BIT | log n | нет | сумма |
| ST-sum | log n | да | сумма + add |
| ST-min | log n | да | минимум |
| ST-assign | log n | да | присваивание |</p><p>---</p><p><h1>Полезные трюки</h1>
<ul>
<li>`inf = 1e18` для минимумов;</li>
<li>`-inf = -1e18` для максимумов;</li>
<li>Нейтральный узел должен быть корректным;</li>
<li>Используй `sz = r - l` в суммах;</li>
<li>Всегда вызывай `push()` при рекурсии вниз.</li>
</ul></p><p>---</p><p><h1>Литература</h1>
<ul>
<li>emaxx.ru — <i>Дерево отрезков</i></li>
<li>KACTL — segment tree</li>
<li>cp-algorithms.com</li>
<li>Codeforces</li>
</ul></p><p></p>

  </main>
</div>

<div class="menu">
  <div class="toc"><strong>Оглавление</strong>
    <ul>
      <li><a href="#definition">Введение</a></li>
      <li><a href="#structure">Структура</a></li>
      <li><a href="#code">Код</a></li>
      <li><a href="#examples">Примеры</a></li>
    </ul>
  </div>
</div>

<script src="scripts/premium.js"></script>
</body>
</html>
